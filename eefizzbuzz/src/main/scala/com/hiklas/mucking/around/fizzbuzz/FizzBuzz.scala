package com.hiklas.mucking.around.fizzbuzz

object FizzBuzz extends App {
  println("FizzBuzz main code")
}

class FizzBuzz
{

  case class OutputCounter(fizz: Int, buzz: Int, fizzbuzz: Int, luck: Int, digit: Int)
  {
    def +(right: OutputCounter): OutputCounter =
    {
      return OutputCounter(0,0,0,0,0)
    }
  }


  /**
    * For a list of numbers the output is another list and a total.
    *
    * [ a, b, c, d, e, f, g ] -> ( [ fn(a), fn(b), fn(c), fn(d), fn(e), fn(f), fn(g) ] , ( totals ) )
    *
    * The final output can be generated by prepending the current element to the
    * result list from the rest and adding the totals.
    *
    * The totals itself is a tuple ( fizzTotal, buzzTotal, fizzbuzzTotal, luckTotal, digitTotal)
    */
  def processAndSumList(listToProcess: List[Int]): (List[String], (Int, Int, Int, Int, Int) ) =
  {
    if ( listToProcess.isEmpty )
    {
      return ( List[String](), (0,0,0,0,0) )
    }

    if ( listToProcess.tail == Nil)
    {
      val resultString = checkOneNumber(listToProcess.head)

      return ( resultString :: Nil, (0,0,0,0,1))
    }
    else
    {

    }

    // TODO: Just dummy data
    ( List[String](), (255,255,255,255,255) )
  }



  def sumCount(left: (Int, Int, Int, Int, Int), right: (Int, Int, Int, Int, Int)): (Int, Int, Int, Int, Int) =
  {
    // TODO: Is there a better way to add tuples?  Or does scala have a matrix type
    // TODO: This seems awfully messy and I wonder if it can be done better?
    (
      left._1 + right._1,
      left._2 + right._2,
      left._3 + right._3,
      left._4 + right._4,
      left._5 + right._5
    )
  }

  def countOutput(): OutputCounter =
  {
    OutputCounter(0,0,0,0,0)
  }

  /**
    * Takes a single integer and figures out whether to leave it as a number,
    * or convert it to fizz, buzz, or luck.
    *
    * @param numberToTest
    * @return String output for the number
    */
  def checkOneNumber(numberToTest: Int): String =
  {
    if( containsDigitThree(numberToTest) )
    {
      return "luck"
    }

    if( divideByThreeTest(numberToTest) && divideByFiveTest(numberToTest) )
    {
      return "fizzbuzz"
    }

    if( divideByThreeTest(numberToTest) )
    {
      return "fizz"
    }

    if( divideByFiveTest(numberToTest) )
    {
      return "buzz"
    }

    // Default
    numberToTest.toString
  }


  private def divideByThreeTest(numberToTest: Int): Boolean =
  {
    divideByNumberTest(numberToTest, 3)
  }

  private def divideByFiveTest(numberToTest: Int): Boolean =
  {
    divideByNumberTest(numberToTest, 5)
  }

  /**
    * Check if the number contains a '3' digit
    *
    * TODO: This does not handle nulls very well!
    *
    * @param numberToTest
    * @return
    */
  private def containsDigitThree(numberToTest: Int): Boolean =
  {
    numberToTest.toString().contains("3")
  }


  /**
    * Check that the given numberToTest can be divided equally by the divisor.
    * If the number to test is zero return false also - normally the
    * modulus operation of 0 returns 0 which leads to a false positive.
    *
    * NOTE: This code assumes that the divisor is non-zero, a DivideByZero exception
    * will be raised if this is not the case.
    *
    * @param numberToTest
    * @param divisor
    * @return
    */
  private def divideByNumberTest(numberToTest: Int, divisor: Int): Boolean =
  {
    numberToTest != 0 && ( numberToTest % divisor) == 0
  }
}


